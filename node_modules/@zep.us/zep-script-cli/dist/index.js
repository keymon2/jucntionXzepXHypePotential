"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = void 0;
const chalk_1 = __importDefault(require("chalk"));
const commander_1 = require("commander");
const commands_1 = require("./commands");
const logger_1 = __importDefault(require("./tools/logger"));
const handleError = (err) => {
    logger_1.default.enable();
    const verbose = commander_1.program.opts().verbose;
    if (verbose) {
        logger_1.default.error(err.message);
    }
    else {
        // Some error messages (esp. custom ones) might have `.` at the end already.
        const message = err.message.replace(/\.$/, "");
        logger_1.default.error(`${message}.`);
    }
    if (err.stack) {
        logger_1.default.log(err.stack);
    }
    if (!verbose) {
        logger_1.default.info(chalk_1.default.dim(`Run CLI with ${chalk_1.default.reset("--verbose")} ${chalk_1.default.dim("flag for more details.")}`));
    }
    process.exit(1);
};
function attachCommand(command) {
    var _a;
    const cmd = commander_1.program
        .command(command.name)
        .action(async function handleAction(...args) {
        const passedOptions = this.opts();
        const argv = Array.from(args).slice(0, -1);
        try {
            await command.func(argv, passedOptions);
        }
        catch (error) {
            if (error instanceof Error) {
                handleError(error);
            }
        }
    });
    if (command.description) {
        cmd.description(command.description);
    }
    for (const opt of command.options || []) {
        cmd.option(opt.name, (_a = opt.description) !== null && _a !== void 0 ? _a : "", opt.parse || ((val) => val), opt.default);
    }
}
async function setupAndRun() {
    commander_1.program.option("-v, --verbose", "Log all outputs");
    for (const command of commands_1.commands) {
        attachCommand(command);
    }
    commander_1.program.parse();
}
async function run() {
    try {
        await setupAndRun();
    }
    catch (e) {
        if (e instanceof Error) {
            handleError(e);
        }
    }
}
exports.run = run;
